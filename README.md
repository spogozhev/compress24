# compress24

Реализация некоторых алгоритмов сжатия. Группа 23.Б11-пу, 1 курс, 2023-2024 учебный год, весенний семестр.

## RLE
* [Кодирование длин серий](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B4%D0%BB%D0%B8%D0%BD_%D1%81%D0%B5%D1%80%D0%B8%D0%B9)

Кодирование длин серий (run-length encoding, RLE) — алгоритм сжатия данных, заменяющий повторяющиеся символы на один символ и число его повторов. 

Рассмотрим произвольную строку символов: `AAAAABBBCCCCCCCCCAAAABAAAAAAAA`

Посчитаем количество символов:

* 5 символов «A»
* 3 символа «B»
* 9 символов «C»
* 4 символа «A»
* 1 символ «B»
* 8 символов «A»

Итого найдено 6 серий. Заменим серии на число повторов и сам повторяющийся символ: `5A3B9C4A1B8A`.

Получилась последовательность из 12 символов. Исходная последовательность состояла из 30 символов. Данные были сжаты в 30/12≈2.5 раза.

Возьмём строку, состоящую из большого количества неповторяющихся символов: `ABCABCABCDDDEEEEEE`

После сжатия методом RLE такая строка будет выглядеть так: `1A1B1C1A1B1C1A1B1C3D6E`

Исходная строка состоит из 18 символов, а сжатая — из 22. Размер данных увеличился в 22/18≈1.22 раза.

Увеличение размера после сжатия произошло из-за того, что есть 9 символов подряд, которые были только по 1 разу.
Можно было бы компактнее записать, что следующие 9 символов встречаются по одному разу, а далее 3 раза D, 6 раз E. 
Чтобы в дальнейшем различать, что означает записанное число, договоримся, что положительные числа будем использовать для записи количества повторов одного символа, 
а отрицательные — для записи количества неодинаковых символов, следующих друг за другом.

Тогда сжатая строка запишется в виде: `-9ABCABCABC3D6E`.

Исходная строка состоит из 18 символов, а сжатая — из 15. Размер данных уменьшился в 18/15=1.2 раза.

Но тогда нужно хранить отдельно знак `-`. Нужно сделать так, чтобы количество символов, встречающихся по одному разу, и количество повторяющихся символов можно было бы записать одним символом (байтом).

Для записи длин серий (для подсчёта количества символов) используем переменную целочисленного типа со знаком `signed char`. 
В такую переменную можно записать числа от -128 до 127 включительно. 
Учтем, что нет необходимости записывать, что какой-то символ повторился 0 раз. Тогда, если длина серии будет отрицательное число, то его модуль будет означать сколько символов далее в последовательности встречаются по одному разу.
А если длина серии является неотрицательным числом `Х`, то оно означает, что следующий символ встретился в последовательности `X+1` раз.

Тогда сжатая строка запишется в виде: `-9ABCABCABC2D5E` (число -9 записывается одним байтом, поэтому здесь будет 14 байт).

Как же быть, если длина серии равна 129 символам и более? В этом случае серию разделяют на части так, чтобы длина части не превышала 128 символов. 
Например, серия, состоящая из 200 символов «A», будет закодирована следующей строкой (200=128+72): `127A71A` (здесь число 128 — это один байт, число 71 тоже, то есть в шестнадцатеричном виде строка `7F 41 47 41`).

## MTF
* [Преобразование MTF](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_MTF)

## BWT
* [Методы сжатия данных. Глава 5. Преобразование Барроуза-Уилера] (https://compression.ru/book/pdf/compression_methods_part1_5-7.pdf)
* [Преобразование Барроуза-Уилера] (https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%91%D0%B0%D1%80%D1%80%D0%BE%D1%83%D0%B7%D0%B0-%D0%A3%D0%B8%D0%BB%D0%B5%D1%80%D0%B0)

## LZW

## Арифметическое кодирование

TODO

## Алгоритм сжатия LZ77

LZ77 — алгоритм сжатия без потерь, опубликованный Абрахамом Лемпелем и Якобом Зивом в 1977. 
Часто в кодируемых строках содержатся совпадающие длинные подстроки. 
В основе LZ77 лежит идея, заключающаяся в замене повторений на ссылки на позиции в тексте, где такие подстроки уже встречались.

Информацию о повторении можно закодировать парой чисел — смещением назад от текущей позиции (offset) и длиной совпадающей подстроки (length). 
Алгоритм LZ77 кодирует ссылки блоками из трёх элементов — `(offset, length, next)`. Параметр `next`  означает первый символ после найденного совпадающего фрагмента. 
Если LZ77 не удалось найти совпадение, то считается, что `offset=0` и `length=0`.

Для эффективного поиска повторов в LZ77 применяется метод «скользящего окна» — совпадения ищутся не на всём обработанном префиксе, а в небольшом буфере, состоящем из последних обработанных символов. 

Для хранения значений offset и length будем использовать по одному байту. Таким образом, буфер будем брать длиной 128 символов. Примечание: обычно длину буфера берут равной 2, 4 или 32KB.

### Пример
Рассмотрим пример кодирования на строке `abacabacabadaca` с буфером размера 5.

|Буфер | Строка          | Совпадение | Код     | Примечание                                                        | 
|-----:| --------------- | ---------- | ------- | ----------------------------------------------------------------- | 
|      | abacabacabadaca |            | (0,0,a) | Буфер сначала пуст                                                | 
|    a | bacabacabadaca  |            | (0,0,b) | В буфере нет `b`, значит нет совпадений                           | 
|   ab | acabacabadaca   | a          | (2,1,c) |                                                                   | 
| abac | abacabadaca     | abacaba    | (4,7,d) | length может быть более offset                                    | 
|cabad | aca             | a          | (2,1,c) |                                                                   | 
|badac | a               | a          | (2,1, ) | После символа `a` строка заканчивается, поэтому next не определен | 

Результатом кодирования является список полученных троек: `(0,0,a) (0,0,b) (2,1,c) (4,7,d) (2,1,c) (2,1, )`

## Алгоритм Хаффмана

Алгоритм Хаффмана — жадный алгоритм оптимального префиксного кодирования алфавита с минимальной избыточностью. 

Состоит из двух основных этапов. 
Алгоритм Хаффмана на входе получает таблицу частотностей символов в сообщении. 
Далее на основании этой таблицы строится дерево кодирования Хаффмана.

1. Символы входного алфавита образуют список свободных узлов. Каждый лист имеет вес, который может быть равен либо вероятности, либо количеству вхождений символа в сжимаемое сообщение.
2. Выбираются два свободных узла дерева с наименьшими весами.
3. Создается их родитель с весом, равным их суммарному весу.
4. Родитель добавляется в список свободных узлов, а два его потомка удаляются из этого списка.
5. Одной дуге, выходящей из родителя, ставится в соответствие бит 1, другой — бит 0. Битовые значения ветвей, исходящих от корня, не зависят от весов потомков.
6. Шаги, начиная со второго, повторяются до тех пор, пока в списке свободных узлов не останется только один свободный узел. Он и будет считаться корнем дерева.

### Пример
Пусть у нас есть сообщение в котором встречаются только 5 разных символов: `ABCDEAABBCDAE...`

Пусть символы в сообщении встречаются:
* A — 16 раз
* B — 8 раз
* C — 7 раз
* D — 6 раз
* E — 5 раз

Тогда коды Хаффмана символов будут выглядеть следующим образом:

* A — `0`
* B — `100`
* C — `101`
* D — `110`
* E — `111`

И исходное сообщение будет кодироваться потоком бит: `0100101110111001001001011100111...`

Поскольку ни один из полученных кодов не является префиксом другого, они могут быть однозначно декодированы при чтении их из потока. Кроме того, наиболее частый символ сообщения `A` закодирован наименьшим количеством бит.


## Источники
* [Ватолин Д., Ратушняк А., Смирнов М., Юкин В. Методы сжатия данных. Устройство архиваторов, сжатие изображений и видео. - М.: ДИАЛОГ-МИФИ, 2002. - 384 с.](https://compression.ru/book/)
* [The Canterbury Corpus](https://corpus.canterbury.ac.nz/descriptions/)
